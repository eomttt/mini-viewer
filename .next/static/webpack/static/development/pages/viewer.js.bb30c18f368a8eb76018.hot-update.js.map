{"version":3,"file":"static/webpack/static/development/pages/viewer.js.bb30c18f368a8eb76018.hot-update.js","sources":["webpack:///./pages/viewer.tsx"],"sourcesContent":["import React, {\n  useState, useMemo, useEffect, useCallback,\n} from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { NextPageContext, NextPage } from 'next';\n\n\nimport styled from 'styled-components';\n\nimport ViewerBottom from '../components/viewer/ViewerBottom';\nimport ViewerCalculator from '../components/viewer/ViewerCalculator';\nimport ViewerHeader from '../components/viewer/ViewerHeader';\nimport ViewerPage from '../components/viewer/ViewerPage';\n\nimport * as viewerActions from '../reducers/viewer';\n\nimport { getBookInfo, getStyleText } from '../lib/util';\n\nimport { VIEWER_WIDTH_RATIO, VIEWER_HEIGHT_RATIO } from '../constants/viewer';\n\nimport { ReducerState } from '../interfaces';\nimport { EpubBook } from '../interfaces/books';\nimport Layout from '../components/Layout';\n\nconst Container = styled.div`\n  padding: ${(100 - VIEWER_HEIGHT_RATIO) / 2}% ${(100 - VIEWER_WIDTH_RATIO) / 2}%;\n  height: ${(props) => props.styleProps.height}px;\n  background-color: ${(props) => props.styleProps.backgroundColor};\n  text-align: center;\n  overflow: hidden;\n`;\n\ninterface Props {\n  book: EpubBook;\n  viewers: string[];\n  styleText: string;\n}\n\nconst Viewer: NextPage<Props> = ({ book, viewers, styleText }) => {\n  const {\n    spines, titles, ncx, contributors,\n  } = book;\n  const dispatch = useDispatch();\n\n  const [viewerWidth, setViewerWidth] = useState(0);\n  const [viewerHeight, setViewerHeight] = useState(0);\n  const [nowSpineIndex, setNowSpineIndex] = useState(0);\n  const [wholePageCount, setWholePageCount] = useState(0);\n\n  const {\n    viewerCountList, viewerPageCount,\n  } = useSelector((state: ReducerState) => state.viewer);\n  const {\n    fontSize, widthRatio, lineHeight, backgroundColor,\n  } = useSelector((state: ReducerState) => state.viewerSetting);\n\n  const isAnalyzedSpine = useMemo(() => viewerCountList.length >= viewers.length, [viewerCountList, viewers]);\n  const isFirstPage = useMemo(() => viewerPageCount === 0, [viewerPageCount]);\n  const isLastPage = useMemo(() => viewerPageCount === wholePageCount, [viewerPageCount, wholePageCount]);\n  const selectedSpineIndex = useMemo(() => {\n    let spineIndex = 0;\n    let accurateCount = 0;\n    viewerCountList.some((viewerCount) => {\n      if (accurateCount + viewerCount.count > viewerPageCount) {\n        spineIndex = viewerCount.index;\n        return true;\n      }\n      accurateCount += viewerCount.count;\n      return false;\n    });\n    return spineIndex;\n  }, [viewerPageCount, viewerCountList]);\n  const pageColumnOffset = useMemo(() => {\n    let columnOffset = viewerPageCount;\n    viewerCountList.some((viewerCount, index) => {\n      if (index < nowSpineIndex) {\n        columnOffset -= (viewerCount.count);\n        return false;\n      }\n      return true;\n    });\n    return columnOffset;\n  }, [viewerCountList, viewerPageCount, nowSpineIndex]);\n\n  useEffect(() => {\n    setViewerWidth(Math.floor(window.innerWidth * (VIEWER_WIDTH_RATIO / 100)));\n    setViewerHeight(Math.floor(window.innerHeight * (VIEWER_HEIGHT_RATIO / 100)));\n    return () => {\n      dispatch(viewerActions.initViewerState());\n    };\n  }, [dispatch]);\n\n  useEffect(() => {\n    console.log('Now spine index', selectedSpineIndex);\n    setNowSpineIndex(selectedSpineIndex);\n  }, [selectedSpineIndex]);\n\n  useEffect(() => {\n    if (isAnalyzedSpine) {\n      console.log('Set whole page count');\n      const pageCount = viewerCountList.reduce((acc, cur) => acc + cur.count, 0);\n      setWholePageCount(pageCount - 1);\n    }\n  }, [isAnalyzedSpine, viewerCountList]);\n\n  useEffect(() => {\n    console.log('New style');\n    dispatch(viewerActions.initViewerState());\n  }, [dispatch, fontSize, lineHeight, widthRatio]);\n\n  const calculateViewerWidth = useCallback(\n    (nowWidth, newRatio) => Math.floor(Number(nowWidth) * (Number(newRatio) / 100)),\n    [],\n  );\n\n  return (\n    <Layout\n      styleText={styleText}\n    >\n      <ViewerHeader\n        titles={titles}\n        authors={contributors}\n        ncxItem={ncx}\n      />\n      <Container\n        styleProps={{\n          height: viewerHeight,\n          backgroundColor,\n        }}\n      >\n        {isAnalyzedSpine\n        && (\n        <ViewerPage\n          viewerWidth={calculateViewerWidth(viewerWidth, widthRatio)}\n          viewerHeight={viewerHeight}\n          pageColumnOffset={pageColumnOffset}\n          viewerSpine={viewers[nowSpineIndex]}\n          isFirstPage={isFirstPage}\n          isLastPage={isLastPage}\n        />\n        )}\n        {!isAnalyzedSpine\n        && (\n        <ViewerCalculator\n          viewerWidth={calculateViewerWidth(viewerWidth, widthRatio)}\n          viewerHeight={viewerHeight}\n          spines={spines}\n          viewers={viewers}\n        />\n        )}\n      </Container>\n      <ViewerBottom\n        sliderMaxValue={wholePageCount}\n      />\n    </Layout>\n  );\n};\n\n// eslint-disable-next-line @typescript-eslint/unbound-method\nViewer.getInitialProps = async (context: NextPageContext<any>): Promise<any> => {\n  const { req, store, query } = context;\n  const { bookPath } = query;\n  const queryPath = decodeURI(String(bookPath || 'epub/jikji'));\n\n  if (req) {\n    // Server side render\n    const { EpubParser } = require('@ridi/epub-parser');\n    const [, fileName] = queryPath.split('/');\n    const publicPath = `http://${req.headers.host}/${queryPath}`;\n    try {\n      const { book, viewers } = await getBookInfo(EpubParser, {\n        epubFile: fileName,\n        epubPath: queryPath,\n      });\n      const styleText = await getStyleText(publicPath, book.styles);\n      return {\n        book,\n        viewers,\n        styleText,\n      };\n    } catch (error) {\n      console.log('Error', error);\n    }\n  } else {\n    // Client side render\n    const { books }: ReducerState = store.getState();\n    const { list } = books;\n\n    let selectedBookInfo = list[0];\n\n    list.some((bookInfo) => {\n      if (bookInfo.publicPath === queryPath) {\n        selectedBookInfo = bookInfo;\n        return true;\n      }\n      return false;\n    });\n\n    const { book, viewers, publicPath } = selectedBookInfo;\n    const styleText = await getStyleText(publicPath, book.styles);\n\n    return {\n      book,\n      viewers,\n      styleText,\n    };\n  }\n};\n\nexport default Viewer;\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAGA;AAIA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAIA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AALA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AACA;AADA;AAaA;AAAA;AAbA;AAAA;AACA;AADA;AAgBA;AAAA;AAhBA;AAAA;AAAA;AAAA;AACA;AAiBA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAIA;AAEA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AACA;AACA;AAFA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AACA;AACA;AACA;AACA;AACA;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYA;AACA;AACA;AACA;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AACA;AACA;AACA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAJA;AAAA;AAAA;AAAA;AACA;AAKA;AANA;AAAA;AASA;AATA;AAAA;AAAA;AAYA;AACA;AAFA;AACA;AAZA;AAAA;AAWA;AAAA;AAXA;AAAA;AACA;AADA;AAeA;AAfA;AAiBA;AACA;AACA;AAHA;AACA;AAjBA;AAAA;AAAA;AAsBA;AACA;AAvBA;AAAA;AAAA;AACA;AADA;AAyBA;AAzBA;AA2BA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AArCA;AAAA;AAAA;AACA;AADA;AAwCA;AAxCA;AA2CA;AACA;AACA;AAHA;AACA;AA3CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAiDA;;;;A","sourceRoot":""}