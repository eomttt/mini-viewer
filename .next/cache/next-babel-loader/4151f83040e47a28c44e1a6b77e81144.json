{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport axios from 'axios';\nexport var getBook = function getBook(parser, _ref) {\n  var unzipPath, book;\n  return _regeneratorRuntime.async(function getBook$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          unzipPath = _ref.unzipPath;\n          _context.prev = 1;\n          _context.next = 4;\n          return _regeneratorRuntime.awrap(parser.parse({\n            validatePackage: true,\n            parseStyle: false,\n            unzipPath: unzipPath\n          }));\n\n        case 4:\n          book = _context.sent;\n          return _context.abrupt(\"return\", book);\n\n        case 8:\n          _context.prev = 8;\n          _context.t0 = _context[\"catch\"](1);\n          console.log('Get book error', _context.t0);\n\n        case 11:\n          return _context.abrupt(\"return\", null);\n\n        case 12:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, [[1, 8]], Promise);\n};\nexport var getViewers = function getViewers(parser, _ref2) {\n  var bookSpines, publicPath, viewers;\n  return _regeneratorRuntime.async(function getViewers$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          bookSpines = _ref2.bookSpines, publicPath = _ref2.publicPath;\n          _context2.prev = 1;\n          _context2.next = 4;\n          return _regeneratorRuntime.awrap(parser.readItems(bookSpines, {\n            force: true,\n            extractBody: true,\n            serializedAnchor: true,\n            ignoreScript: true,\n            basePath: publicPath\n          }));\n\n        case 4:\n          viewers = _context2.sent;\n          return _context2.abrupt(\"return\", viewers);\n\n        case 8:\n          _context2.prev = 8;\n          _context2.t0 = _context2[\"catch\"](1);\n          console.log('Get viewers error', _context2.t0);\n\n        case 11:\n          return _context2.abrupt(\"return\", []);\n\n        case 12:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, [[1, 8]], Promise);\n};\nexport var getBookInfo = function getBookInfo(EpubParser, _ref3) {\n  var epubFile, epubPath, parser, book, viewers;\n  return _regeneratorRuntime.async(function getBookInfo$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          epubFile = _ref3.epubFile, epubPath = _ref3.epubPath;\n          parser = new EpubParser(\"public/\".concat(epubFile, \".epub\"));\n          _context3.prev = 2;\n          _context3.next = 5;\n          return _regeneratorRuntime.awrap(getBook(parser, {\n            unzipPath: \"public/\".concat(epubPath)\n          }));\n\n        case 5:\n          book = _context3.sent;\n\n          if (!book) {\n            _context3.next = 11;\n            break;\n          }\n\n          _context3.next = 9;\n          return _regeneratorRuntime.awrap(getViewers(parser, {\n            bookSpines: book.spines,\n            publicPath: epubPath\n          }));\n\n        case 9:\n          viewers = _context3.sent;\n          return _context3.abrupt(\"return\", {\n            book: book,\n            viewers: viewers\n          });\n\n        case 11:\n          _context3.next = 16;\n          break;\n\n        case 13:\n          _context3.prev = 13;\n          _context3.t0 = _context3[\"catch\"](2);\n          console.log('Get book info error', _context3.t0);\n\n        case 16:\n          return _context3.abrupt(\"return\", {\n            book: null,\n            viewers: []\n          });\n\n        case 17:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, [[2, 13]], Promise);\n};\nexport var isEpubFile = function isEpubFile(fileName) {\n  return fileName.includes('.epub');\n};\nexport var getStyleText = function getStyleText(publicPath, styles) {\n  var res, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, style, data;\n\n  return _regeneratorRuntime.async(function getStyleText$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          res = []; // eslint-disable-next-line no-restricted-syntax\n\n          _iteratorNormalCompletion = true;\n          _didIteratorError = false;\n          _iteratorError = undefined;\n          _context4.prev = 4;\n          _iterator = styles[Symbol.iterator]();\n\n        case 6:\n          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n            _context4.next = 21;\n            break;\n          }\n\n          style = _step.value;\n          _context4.prev = 8;\n          _context4.next = 11;\n          return _regeneratorRuntime.awrap(axios.get(\"\".concat(publicPath, \"/\").concat(style.href)));\n\n        case 11:\n          data = _context4.sent;\n          res.push(data.data);\n          _context4.next = 18;\n          break;\n\n        case 15:\n          _context4.prev = 15;\n          _context4.t0 = _context4[\"catch\"](8);\n          console.log('Get style text error', _context4.t0);\n\n        case 18:\n          _iteratorNormalCompletion = true;\n          _context4.next = 6;\n          break;\n\n        case 21:\n          _context4.next = 27;\n          break;\n\n        case 23:\n          _context4.prev = 23;\n          _context4.t1 = _context4[\"catch\"](4);\n          _didIteratorError = true;\n          _iteratorError = _context4.t1;\n\n        case 27:\n          _context4.prev = 27;\n          _context4.prev = 28;\n\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n\n        case 30:\n          _context4.prev = 30;\n\n          if (!_didIteratorError) {\n            _context4.next = 33;\n            break;\n          }\n\n          throw _iteratorError;\n\n        case 33:\n          return _context4.finish(30);\n\n        case 34:\n          return _context4.finish(27);\n\n        case 35:\n          return _context4.abrupt(\"return\", res.join(''));\n\n        case 36:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, null, null, [[4, 23, 27, 35], [8, 15], [28,, 30, 34]], Promise);\n};","map":{"version":3,"sources":["/Users/hyuntaeeom/Projects/personal/mini-viewer/lib/util.ts"],"names":["axios","getBook","parser","unzipPath","parse","validatePackage","parseStyle","book","console","log","getViewers","bookSpines","publicPath","readItems","force","extractBody","serializedAnchor","ignoreScript","basePath","viewers","getBookInfo","EpubParser","epubFile","epubPath","spines","isEpubFile","fileName","includes","getStyleText","styles","res","style","get","href","data","push","join"],"mappings":"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","sourcesContent":["import axios from 'axios';\nimport { EpubBook } from '../interfaces/books';\n\nexport const getBook = async (parser, {\n  unzipPath,\n}): Promise<EpubBook | null> => {\n  try {\n    const book: EpubBook = await parser.parse({\n      validatePackage: true,\n      parseStyle: false,\n      unzipPath,\n    });\n\n    return book;\n  } catch (error) {\n    console.log('Get book error', error);\n  }\n\n  return null;\n};\n\nexport const getViewers = async (parser, {\n  bookSpines,\n  publicPath,\n}): Promise<string[]> => {\n  try {\n    const viewers = await parser.readItems(bookSpines, {\n      force: true,\n      extractBody: true,\n      serializedAnchor: true,\n      ignoreScript: true,\n      basePath: publicPath,\n    });\n\n    return viewers;\n  } catch (error) {\n    console.log('Get viewers error', error);\n  }\n\n  return [];\n};\n\nexport const getBookInfo = async (EpubParser, {\n  epubFile,\n  epubPath,\n}): Promise<{\n  book: EpubBook | null;\n  viewers: string[];\n}> => {\n  const parser = new EpubParser(`public/${epubFile}.epub`);\n  try {\n    const book: EpubBook = await getBook(parser, {\n      unzipPath: `public/${epubPath}`,\n    });\n\n    if (book) {\n      const viewers = await getViewers(parser, {\n        bookSpines: book.spines,\n        publicPath: epubPath,\n      });\n\n      return {\n        book,\n        viewers,\n      };\n    }\n  } catch (error) {\n    console.log('Get book info error', error);\n  }\n\n  return {\n    book: null,\n    viewers: [],\n  };\n};\n\nexport const isEpubFile = (fileName) => {\n  return fileName.includes('.epub');\n};\n\nexport const getStyleText = async (publicPath, styles) => {\n  const res = [];\n  // eslint-disable-next-line no-restricted-syntax\n  for (const style of styles) {\n    try {\n      const data = await axios.get(`${publicPath}/${style.href}`);\n      res.push(data.data);\n    } catch (error) {\n      console.log('Get style text error', error);\n    }\n  }\n\n  return res.join('');\n};\n"]},"metadata":{},"sourceType":"module"}